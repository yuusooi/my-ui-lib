<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        Function.prototype.myBind = function (context, ...args1) {
            // 1. 保存当前函数（原函数）
            const self = this;

            // 容错：调用 myBind 的必须是函数
            if (typeof self !== 'function') {
                throw new Error("只能对函数使用 bind");
            }

            // 2. 返回一个新的函数
            const boundFn = function (...args2) {
                // 3. 处理参数合并：bind 时的参数 + 调用时的参数
                const allArgs = [...args1, ...args2];

                // 4. 判断是否被 new 调用 (高频考点！)
                // 如果是 new 调用，this 指向实例（也就是 this instanceof boundFn 为 true）
                // 此时忽略传入的 context，this 就是当前的 this
                // 如果是普通调用，this 指向传入的 context
                const isNew = this instanceof boundFn;

                return self.apply(isNew ? this : context, allArgs);
            };

            // 5. 维护原型关系 (让 new 出来的实例能继承原函数原型上的属性)
            // 使用 Object.create 避免修改 boundFn.prototype 时影响原函数
            if (self.prototype) {
                boundFn.prototype = Object.create(self.prototype);
            }

            return boundFn;
        };
    </script>
</body>
</html>